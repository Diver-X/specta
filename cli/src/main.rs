use nanoid::nanoid;
use quote::quote;
use std::{
    fs, io,
    path::{Path, PathBuf},
    process::Command,
    time::Instant,
};

use clap::Parser;
use syn::{Item, ItemStruct, Type};

#[derive(Debug, Parser)]
struct Args {
    #[arg(short, long)]
    path: Vec<PathBuf>,
    #[arg(short, long)]
    bindgen: bool,
}

// TODO: Improved error handling + render them nicely
fn main() {
    let start = Instant::now(); // TODO: Tracing spans

    let args = Args::parse();

    for path in args.path {
        match crawl_dir(&path) {
            Ok(m) => m,
            Err(err) if err.kind() == std::io::ErrorKind::NotFound => {
                println!("File '{}' does not exist", path.display());
                continue;
            }
            Err(err) => panic!("Error processing file: '{}': {}", path.display(), err),
        };
    }

    if args.bindgen {
        // TODO: Allow the user to set the path
        let content = "export type TODO = ();"; // TODO: Make this work

        fs::write(
            "./types.rs",
            format!(r##"// This file was generated by the [Specta CLI](https://github.com/oscartbeaumont/specta). Do not edit this file manually.

#[wasm_bindgen(typescript_custom_section)]
const TS_APPEND_CONTENT: &'static str = r#"{content}"#;"##,
        ))
        .unwrap();
    }

    println!("Finished in {:?}", start.elapsed());
}

fn crawl_dir(path: &Path) -> io::Result<()> {
    let metadata = path.metadata()?;

    if metadata.is_file() {
        parse_file(path);
    } else if metadata.is_dir() {
        println!("Dir: {:?}", path);

        todo!();
    } else {
        // TODO: We should probs support symlinks???
        panic!("Found file '{path:?}' that is neither a file nor a directory");
    }

    Ok(())
}

fn parse_file(path: &Path) {
    let file = fs::read_to_string(path).unwrap();
    let ast = syn::parse_file(&file).unwrap();

    for node in ast.items {
        match node {
            // Not Specta's compatible
            Item::Const(_)
            | Item::ExternCrate(_)
            | Item::ForeignMod(_)
            | Item::Impl(_)
            | Item::Macro(_)
            | Item::Macro2(_)
            | Item::Static(_)
            | Item::Trait(_)
            | Item::TraitAlias(_)
            | Item::Type(_)
            | Item::Union(_)
            | Item::Use(_)
            | Item::Verbatim(_) => {}
            Item::Fn(_) => {
                // TODO: Maybe support functions that don't use `impl T`
            }
            Item::Mod(_) => {
                // TODO: Support modules
            }
            Item::Enum(_) => {
                // TODO: Support enums
            }
            Item::Struct(s) => {
                temp_parse_struct(s);
                // println!("FOUND STRUCT: {s:#?}");
                // TODO: Support structs
            }
            node => {
                // TODO: Display as a pretty warning
                println!("Found unsupported item: '{:#?}'", node);
            }
        }
    }

    // TODO:
}

// TODO: Abstract this and move it into the macro-support crate
fn temp_parse_struct(item: ItemStruct) {
    println!("STRUCT {}", item.ident.to_string());
    for field in item.fields {
        // TODO: Account for Specta and Serde attributes (including `cfg_attr` and the current features, idk how that would work)

        println!(
            "\t{} {:?}",
            field.ident.unwrap().to_string(),
            resolve_type(field.ty)
        );
    }
}

// TODO: Allow this to run in parallel without the Cargo `target` dir lock being an issue????
// TODO: Maybe short circuit out of this for primitive types (but check `use`'s that they weren't redefined)
// TODO: Cache the result if the type shows up more than once in a single file.
fn resolve_type(ty: Type) -> String {
    let crate_path = "./"; // TODO: Proper determine this using `cargo metadata`

    // TODO: Error out if `specta` is not in their dependencies for the current crate (as we use it in the generated code)
    // TODO: Also check feature flags for TS, etc unless we serialize the AST to JSON and do it in the macro

    let examples_dir = Path::new(crate_path).join("examples");

    let has_examples_dir = examples_dir.exists();
    fs::create_dir_all(&examples_dir).unwrap();
    let name = nanoid!(5);
    let path = examples_dir.join(format!("{}.rs", name));

    // TODO: On drop handler to ensure this file is cleaned up

    // TODO: What if this refers to an external type, Eg. `Uuid`? We will need to move over the `use uuid::Uuid`;
    // TODO: What if the `use` came from a macro expansion - We would need to error out due to the type being ambiguous

    fs::write(
        &path,
        quote! {
            fn main() {
                // TODO: Handle errors properly
                // TODO: This should `reference` not `inline`
                let ty = specta::ts::inline::<#ty>(&Default::default()).unwrap();
                println!("{ty}");
            }
        }
        .to_string(),
    )
    .unwrap();

    let command = Command::new("cargo")
        .arg("run")
        .arg("--example")
        .arg(name)
        // .current_dir(dir) // TODO
        .output()
        .unwrap();
    // TODO: Check `command.status`

    // TODO: Why is it `stderr`???
    let result = String::from_utf8(command.stdout)
        .expect("non-utf8 command output")
        .trim()
        .to_string();

    fs::remove_file(path).unwrap();
    if !has_examples_dir {
        fs::remove_dir(examples_dir).unwrap();
    }

    return result;
}
