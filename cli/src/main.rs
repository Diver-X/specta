use std::{
    fs, io,
    path::{Path, PathBuf},
};

use clap::Parser;
use syn::Item;

#[derive(Debug, Parser)]
struct Args {
    #[arg(short, long)]
    path: Vec<PathBuf>,
    #[arg(short, long)]
    bindgen: bool,
}

// TODO: Improved error handling + render them nicely
fn main() {
    let args = Args::parse();

    for path in args.path {
        match crawl_dir(&path) {
            Ok(m) => m,
            Err(err) if err.kind() == std::io::ErrorKind::NotFound => {
                println!("File '{}' does not exist", path.display());
                continue;
            }
            Err(err) => panic!("Error processing file: '{}': {}", path.display(), err),
        };
    }

    if args.bindgen {
        // TODO: Allow the user to set the path
        let content = "export type TODO = ();"; // TODO: Make this work

        fs::write(
            "./types.rs",
            format!(r##"// This file was generated by the [Specta CLI](https://github.com/oscartbeaumont/specta). Do not edit this file manually.

#[wasm_bindgen(typescript_custom_section)]
const TS_APPEND_CONTENT: &'static str = r#"{content}"#;"##,
        ))
        .unwrap();
    }
}

fn crawl_dir(path: &Path) -> io::Result<()> {
    let metadata = path.metadata()?;

    if metadata.is_file() {
        parse_file(path);
    } else if metadata.is_dir() {
        println!("Dir: {:?}", path);

        todo!();
    } else {
        // TODO: We should probs support symlinks???
        panic!("Found file '{path:?}' that is neither a file nor a directory");
    }

    Ok(())
}

fn parse_file(path: &Path) {
    let file = fs::read_to_string(path).unwrap();
    let ast = syn::parse_file(&file).unwrap();

    for node in ast.items {
        match node {
            // Not Specta's compatible
            Item::Const(_)
            | Item::ExternCrate(_)
            | Item::ForeignMod(_)
            | Item::Impl(_)
            | Item::Macro(_)
            | Item::Macro2(_)
            | Item::Static(_)
            | Item::Trait(_)
            | Item::TraitAlias(_)
            | Item::Type(_)
            | Item::Union(_)
            | Item::Use(_)
            | Item::Verbatim(_) => {}
            Item::Fn(_) => {
                // TODO: Maybe support functions that don't use `impl T`
            }
            Item::Mod(_) => {
                // TODO: Support modules
            }
            Item::Enum(_) => {
                // TODO: Support enums
            }
            Item::Struct(s) => {
                println!("FOUND STRUCT: {s:#?}");
                // TODO: Support structs
            }
            node => {
                // TODO: Display as a pretty warning
                println!("Found unsupported item: '{:#?}'", node);
            }
        }
    }

    // TODO:
}
