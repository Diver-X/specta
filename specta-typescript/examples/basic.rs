use specta::{datatype::{self, FunctionResultVariant}, Type, TypeCollection};
use specta_typescript::{inline, Typescript};

#[derive(Type)]
pub struct TypeOne {
    pub field1: String,
    pub field2: i32,
    pub test: TypeTwo,
}

#[derive(Type)]
pub struct TypeTwo {
    pub field1: String,
    pub field2: i32,
}


// #[derive(Type)]
// pub struct GenericType<A> {
//     pub my_field: String,
//     pub generic: A,
// }

// #[derive(Type, Hash)]
// pub enum MyEnum {
//     A,
//     B,
//     C,
// }

// #[derive(Type)]
// pub struct Something {
//     a: HashMap<MyEnum, i32>,
// }

fn main() {
    let mut types = TypeCollection::default()
        .register::<TypeOne>();
         // notice how we don't list `TypeTwo`. It's a dependency of `TypeOne` and will be exported automatically.
    // TODO: Rest of them

    // TODO: Remove this stuff
    {
        let dt = specta::datatype::reference::inline::<TypeOne>(&mut types);
        println!("{:?}", specta_typescript::datatype(&Typescript::default(), &FunctionResultVariant::Value(dt), &types));

        // let dt = specta::datatype::reference::inline::<TypeOne>(&mut types, &[]);
        println!("{:?}\n\n", specta_typescript::inline::<TypeOne>(&Default::default()));
    }

    Typescript::default()
        .export_to("./bindings.ts", &types)
        .unwrap();

    let result = std::fs::read_to_string("./bindings.ts").unwrap();
    println!("{result}");
    assert_eq!(result, r#"// This file has been generated by Specta. DO NOT EDIT.

export type TypeOne = { field1: string; field2: number; test: TypeTwo }

export type TypeTwo = { field1: string; field2: number }

"#);
}
